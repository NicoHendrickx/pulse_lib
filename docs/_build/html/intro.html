

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Introduction &mdash; pulse lib 0.2 alpha documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> pulse lib
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="struct.html">Structure of the library</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/init_lib.html">Tutorial : Initializing the library</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/simple_pulse.html">Tutorial : Making simple pulses for DC control of qubits.</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/MW_pulse.html">Tutorial : Making pulses for Microwave control.</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/sequence.html">Tutotial : Making from pulses a sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/looping.html">Tutorial : Looping variables.</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/reset_time_and_slicing.html">Concepts : Reset time and slicing of waveforms.</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/example_PT.html">Advanced Tutorial : Programming a process tomography experiment to characterize a two qubit gate.</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/example_RB.html">Advanced Tutorial : Designing pulses for a Randomised Benchmarking experiment.</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pulse lib</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Introduction</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/intro.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-base_pulse">
<span id="introduction"></span><h1>Introduction<a class="headerlink" href="#module-base_pulse" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="base_pulse.pulselib">
<em class="property">class </em><code class="descclassname">base_pulse.</code><code class="descname">pulselib</code><a class="reference internal" href="_modules/base_pulse.html#pulselib"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#base_pulse.pulselib" title="Permalink to this definition">¶</a></dt>
<dd><p>Global class that is an organisational element in making the pulses.
The idea is that you first make individula segments,
you can than later combine them into a sequence, this sequence will be uploaded</p>
<dl class="method">
<dt id="base_pulse.pulselib.add_IQ_virt_channels">
<code class="descname">add_IQ_virt_channels</code><span class="sig-paren">(</span><em>IQ_virt_channels</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/base_pulse.html#pulselib.add_IQ_virt_channels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#base_pulse.pulselib.add_IQ_virt_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>function to define virtual IQ channels (a channel that combined the I and Q channel for MW applications):
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt>IQ_virt_channels (dict): a dictionary that needs to contain the following keys:</dt>
<dd>‘vIQ_channels’ : list of names of virtual IQ channels
‘r_IQ_channels’: list of list, where in each list the two reference channels (I and Q) are denoted (see docs for example).
‘LO_freq’(function/double) : local oscillating frequency of the source. Will be used to do automaticcally convert the freq a SSB signal.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="base_pulse.pulselib.add_awgs">
<code class="descname">add_awgs</code><span class="sig-paren">(</span><em>name</em>, <em>awg</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/base_pulse.html#pulselib.add_awgs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#base_pulse.pulselib.add_awgs" title="Permalink to this definition">¶</a></dt>
<dd><p>add a awg to the library
Args:</p>
<blockquote>
<div>name (str) : name you want to give to a peculiar AWG
awg (object) : qcodes object of the concerning AWG</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="base_pulse.pulselib.add_channel_compenstation_limits">
<code class="descname">add_channel_compenstation_limits</code><span class="sig-paren">(</span><em>limits</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/base_pulse.html#pulselib.add_channel_compenstation_limits"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#base_pulse.pulselib.add_channel_compenstation_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>add voltage limitations per channnel that can be used to make sure that the intragral of the total voltages is 0.
Args:</p>
<blockquote>
<div>limits (dict) : dict with limits e.g. {‘B0’:(-100,500), … }</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="base_pulse.pulselib.add_channel_delay">
<code class="descname">add_channel_delay</code><span class="sig-paren">(</span><em>delays</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/base_pulse.html#pulselib.add_channel_delay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#base_pulse.pulselib.add_channel_delay" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds to a channel a delay. 
The delay is added by adding points in front of the first sequence/or 
just after the last sequence. The first value of the sequence will be 
taken as an extentsion point.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>delays: dict, e.g. {‘P1’:20, ‘P2’:16} delay P1 with 20 ns and P2 with 16 ns</dd>
<dt>Returns:</dt>
<dd>0/Error</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="base_pulse.pulselib.add_virtual_gates">
<code class="descname">add_virtual_gates</code><span class="sig-paren">(</span><em>virtual_gates</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/base_pulse.html#pulselib.add_virtual_gates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#base_pulse.pulselib.add_virtual_gates" title="Permalink to this definition">¶</a></dt>
<dd><p>define virtual gates for the gate set.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt>virtual_gates (dict): needs to have the following keys:</dt>
<dd>‘virtual_gates_names_virt’ : should constain a list with the channel names of the virtual gates
‘virtual_gates_names_real’ : should constain a list with the channel names of the read gates (should be as long as the virtual ones)
‘virtual_gate_matrix’ : numpy array representing the virtual gate matrix</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="base_pulse.pulselib.define_channels">
<code class="descname">define_channels</code><span class="sig-paren">(</span><em>my_input</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/base_pulse.html#pulselib.define_channels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#base_pulse.pulselib.define_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>define the channels and their location 
Args:</p>
<blockquote>
<div>my_input (dict): dict of the channel name (str) as key and name of the instrument (as given in add_awgs()) (str) and channel (int) as tuple (e.g. {‘chan1’ : (‘AWG1’, 1), … })</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="base_pulse.pulselib.mk_segment">
<code class="descname">mk_segment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/base_pulse.html#pulselib.mk_segment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#base_pulse.pulselib.mk_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a new segment.
Returns:</p>
<blockquote>
<div>segment (segment_container) : returns a container that contains all the previously defined gates.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="base_pulse.pulselib.mk_sequence">
<code class="descname">mk_sequence</code><span class="sig-paren">(</span><em>seq</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/base_pulse.html#pulselib.mk_sequence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#base_pulse.pulselib.mk_sequence" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>seq: list of list, </dt>
<dd>e.g. [ [‘name segment 1’ (str), number of times to play (int), prescale (int)] ]
prescale (default 0, see keysight manual) (not all awg’s will support this).</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-segments.data_classes"></span><dl class="class">
<dt id="segments.data_classes.IQ_data">
<em class="property">class </em><code class="descclassname">segments.data_classes.</code><code class="descname">IQ_data</code><span class="sig-paren">(</span><em>LO</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/data_classes.html#IQ_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.data_classes.IQ_data" title="Permalink to this definition">¶</a></dt>
<dd><p>class that manages the data used for generating IQ data</p>
<dl class="method">
<dt id="segments.data_classes.IQ_data.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>other</em>, <em>time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/data_classes.html#IQ_data.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.data_classes.IQ_data.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append two segments to each other, where the other segment is places after the first segment. Time is the total time of the first segment.
Args:</p>
<blockquote>
<div>other (pulse_data) : other pulse data object to be appended
time (double/None) : length that the first segment should be.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="segments.data_classes.IQ_data.get_IQ_data">
<code class="descname">get_IQ_data</code><span class="sig-paren">(</span><em>I_or_Q</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/data_classes.html#IQ_data.get_IQ_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.data_classes.IQ_data.get_IQ_data" title="Permalink to this definition">¶</a></dt>
<dd><p>get data object containing the I or Q part of the IQ signal
Args:</p>
<blockquote>
<div>I_or_Q (str) : string ‘I’ or ‘Q’ to indicate which part of the signal to return</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>new_data (pulse_data) : normal pulse_data object.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="segments.data_classes.IQ_data.slice_time">
<code class="descname">slice_time</code><span class="sig-paren">(</span><em>start</em>, <em>end</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/data_classes.html#IQ_data.slice_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.data_classes.IQ_data.slice_time" title="Permalink to this definition">¶</a></dt>
<dd><p>slice time in IQ_data class
Args:</p>
<blockquote>
<div>start (double) : new start time of the pulse
end (duoble) : new end time of the pulse</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="segments.data_classes.data_container">
<em class="property">class </em><code class="descclassname">segments.data_classes.</code><code class="descname">data_container</code><a class="reference internal" href="_modules/segments/data_classes.html#data_container"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.data_classes.data_container" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="segments.data_classes.get_effective_point_number">
<code class="descclassname">segments.data_classes.</code><code class="descname">get_effective_point_number</code><span class="sig-paren">(</span><em>time</em>, <em>time_step</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/data_classes.html#get_effective_point_number"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.data_classes.get_effective_point_number" title="Permalink to this definition">¶</a></dt>
<dd><p>function that discretizes time depending on the sample rate of the AWG.
Args:</p>
<blockquote>
<div>time (double): time in ns of which you want to know how many points the AWG needs to get there
time_step (double) : time step of the AWG (ns)</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>how many points you need to get to the desired time step.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="segments.data_classes.pulse_data">
<em class="property">class </em><code class="descclassname">segments.data_classes.</code><code class="descname">pulse_data</code><a class="reference internal" href="_modules/segments/data_classes.html#pulse_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.data_classes.pulse_data" title="Permalink to this definition">¶</a></dt>
<dd><p>object that saves all the pulse data that is present in an segment object.
This object support all the fundametal operations needed to define the segments.</p>
<dl class="method">
<dt id="segments.data_classes.pulse_data.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>other</em>, <em>time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/data_classes.html#pulse_data.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.data_classes.pulse_data.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append two segments to each other, where the other segment is places after the first segment. Time is the total time of the first segment.
Args:</p>
<blockquote>
<div>other (pulse_data) : other pulse data object to be appended
time (double/None) : length that the first segment should be.</div></blockquote>
<p>** what to do with start time argument?</p>
</dd></dl>

<dl class="method">
<dt id="segments.data_classes.pulse_data.get_resized_waveform">
<code class="descname">get_resized_waveform</code><span class="sig-paren">(</span><em>pre_delay</em>, <em>post_delay</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/data_classes.html#pulse_data.get_resized_waveform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.data_classes.pulse_data.get_resized_waveform" title="Permalink to this definition">¶</a></dt>
<dd><p>extend/shrink an existing waveform
Args:</p>
<blockquote>
<div>pre_delay (double) : ns to add before
post_delay (double) : ns to add after the waveform</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>waveform (np.ndarray[ndim=1, dtype=double])</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="segments.data_classes.pulse_data.get_vmax">
<code class="descname">get_vmax</code><span class="sig-paren">(</span><em>sample_rate=1000000000.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/data_classes.html#pulse_data.get_vmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.data_classes.pulse_data.get_vmax" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the maximum voltage in the current segment_single.</p>
<p>If sine waves included, will take the maximum of the total render. Tf not, it just takes the max of the pulse data.</p>
</dd></dl>

<dl class="method">
<dt id="segments.data_classes.pulse_data.get_vmin">
<code class="descname">get_vmin</code><span class="sig-paren">(</span><em>sample_rate=1000000000.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/data_classes.html#pulse_data.get_vmin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.data_classes.pulse_data.get_vmin" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the maximum voltage in the current segment_single.</p>
<p>If sine waves included, will take the minimum of the total render. Tf not, it just takes the min of the pulse data.</p>
</dd></dl>

<dl class="method">
<dt id="segments.data_classes.pulse_data.integrate_waveform">
<code class="descname">integrate_waveform</code><span class="sig-paren">(</span><em>pre_delay</em>, <em>post_delay</em>, <em>sample_rate</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/data_classes.html#pulse_data.integrate_waveform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.data_classes.pulse_data.integrate_waveform" title="Permalink to this definition">¶</a></dt>
<dd><p>takes a full integral of the currently scheduled waveform.
Args:</p>
<blockquote>
<div>start_time (double) : from which points the rendering needs to start
stop_time (double) : to which point the rendering needs to go (default (-1), to entire segement)
sample_rate (double) : rate at which the AWG will be run</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>integrate (double) : the integrated value of the waveform (unit is mV/sec).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="segments.data_classes.pulse_data.render">
<code class="descname">render</code><span class="sig-paren">(</span><em>pre_delay=0</em>, <em>post_delay=0</em>, <em>sample_rate=1000000000.0</em>, <em>clear_cache_on_exit=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/data_classes.html#pulse_data.render"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.data_classes.pulse_data.render" title="Permalink to this definition">¶</a></dt>
<dd><p>renders pulse
Args:</p>
<blockquote>
<div>pre_delay (double) : amount of time to put before the sequence the rendering needs to start
post_delay (double) : to which point in time the rendering needs to go
sample_rate (double) : rate at which the AWG will be run
clear_cache_on_exit (bool) : clear the cache on exit (e.g. when you uploaded this waveform to the AWG, remove reference so the garbarge collector can remove it). The ensured low memory occupation.</div></blockquote>
<dl class="docutils">
<dt>returns</dt>
<dd>pulse (np.ndarray) : numpy array of the pulse</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="segments.data_classes.pulse_data.slice_time">
<code class="descname">slice_time</code><span class="sig-paren">(</span><em>start</em>, <em>end</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/data_classes.html#pulse_data.slice_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.data_classes.pulse_data.slice_time" title="Permalink to this definition">¶</a></dt>
<dd><p>slice the time in the pulse data object.
Args:</p>
<blockquote>
<div>start (double) : new starting time of the pulse (&gt;= 0)
end (double) : new end time of the pulse.</div></blockquote>
<p>Note that the start and end point of the slice will correspond to the zero base level of the pulse.
(you can set the base level by doing my_segment += &lt;double&gt; base_level)</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-segments.segments"></span><dl class="class">
<dt id="segments.segments.segment_container">
<em class="property">class </em><code class="descclassname">segments.segments.</code><code class="descname">segment_container</code><span class="sig-paren">(</span><em>real_channels</em>, <em>virtual_gates=None</em>, <em>IQ_channels=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/segments.html#segment_container"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.segments.segment_container" title="Permalink to this definition">¶</a></dt>
<dd><p>Class containing all the single segments for for a series of channels.
This is a organisational class.
Class is capable of checking wheather upload is needed.
Class is capable of termining what volatages are required for each channel.
Class returns vmin/vmax data to awg object
Class returns upload data as a numpy&lt;double&gt; array to awg object.</p>
<dl class="method">
<dt id="segments.segments.segment_container.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>other</em>, <em>time=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/segments.html#segment_container.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.segments.segment_container.append" title="Permalink to this definition">¶</a></dt>
<dd><p>append other segments the the current ones in the container.
Args:</p>
<blockquote>
<div>other (segment_container) : other segment to append</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="segments.segments.segment_container.enter_rendering_mode">
<code class="descname">enter_rendering_mode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/segments.html#segment_container.enter_rendering_mode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.segments.segment_container.enter_rendering_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>put the segments into rendering mode, which means that they cannot be changed. All segments will get their final length at this moment.</p>
</dd></dl>

<dl class="method">
<dt id="segments.segments.segment_container.exit_rendering_mode">
<code class="descname">exit_rendering_mode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/segments.html#segment_container.exit_rendering_mode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.segments.segment_container.exit_rendering_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>exit rendering mode and clear all the ram that was used for the rendering.</p>
</dd></dl>

<dl class="method">
<dt id="segments.segments.segment_container.extend_dim">
<code class="descname">extend_dim</code><span class="sig-paren">(</span><em>shape=None</em>, <em>ref=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/segments.html#segment_container.extend_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.segments.segment_container.extend_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>extend the dimensions of the waveform to a given shape.
Args:</p>
<blockquote>
<div>shape (tuple) : shape of the new waveform
ref (bool) : put to True if you want to extend the dimension by using pointers instead of making full copies.</div></blockquote>
<p>If referencing is True, a pre-render will already be performed to make sure nothing is rendered double.</p>
</dd></dl>

<dl class="method">
<dt id="segments.segments.segment_container.get_waveform">
<code class="descname">get_waveform</code><span class="sig-paren">(</span><em>channel, index=[0], pre_delay=0, post_delay=0, sample_rate=1000000000.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/segments.html#segment_container.get_waveform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.segments.segment_container.get_waveform" title="Permalink to this definition">¶</a></dt>
<dd><p>function to get the raw data of a waveform,
inputs:</p>
<blockquote>
<div>channel (str) : channel name of the waveform you want
index (tuple) :
pre_delay (int) : extra offset in from of the waveform (start at negative time) (for a certain channel, as defined in channel delays)
post_delay (int) : time gets appended to the waveform (for a certain channel)</div></blockquote>
<dl class="docutils">
<dt>returns:</dt>
<dd>np.ndarray[ndim=1, dtype=double] : waveform as a numpy array</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="segments.segments.segment_container.reset_time">
<code class="descname">reset_time</code><span class="sig-paren">(</span><em>extend_only=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/segments.html#segment_container.reset_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.segments.segment_container.reset_time" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Args:</dt>
<dd>extend_only (bool) : will just extend the time in the segment and not reset it if set to true [do not use when composing wavoforms…].</dd>
</dl>
<p>Allings all segments togeter and sets the input time to 0,
e.g. , 
chan1 : waveform until 70 ns
chan2 : waveform until 140ns
-&gt; totaltime will be 140 ns,
when you now as a new pulse (e.g. at time 0, it will actually occur at 140 ns in both blocks)</p>
</dd></dl>

<dl class="attribute">
<dt id="segments.segments.segment_container.shape">
<code class="descname">shape</code><a class="headerlink" href="#segments.segments.segment_container.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>get combined shape of all the waveforms</p>
</dd></dl>

<dl class="method">
<dt id="segments.segments.segment_container.slice_time">
<code class="descname">slice_time</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/segments.html#segment_container.slice_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.segments.segment_container.slice_time" title="Permalink to this definition">¶</a></dt>
<dd><p>slice time in a segment container
Args:</p>
<blockquote>
<div>start (double) : start time of the slice
stop (double) : stop time of the slice</div></blockquote>
<p>The slice_time function allows you to cut all the waveforms in the segment container in different sizes.
This function should be handy for debugging, example usage would be, 
You are runnning an algorithm and want to check what the measurement outcomes are though the whole algorithm.
Pratically, you want to know</p>
<blockquote>
<div>0 -&gt; 10ns (&#64;10 ns still everything as expected?)
0 -&gt; 20ns
0 -&gt; …</div></blockquote>
<p>This function would allow you to do that, e.g. by calling segment_container.cut_segment(0, lp.linspace(10,100,9))</p>
</dd></dl>

<dl class="attribute">
<dt id="segments.segments.segment_container.total_time">
<code class="descname">total_time</code><a class="headerlink" href="#segments.segments.segment_container.total_time" title="Permalink to this definition">¶</a></dt>
<dd><p>get the total time that will be uploaded for this segment to the AWG
Returns:</p>
<blockquote>
<div>times (np.ndarray) : numpy array with the total time (maximum of all the channels), for all the different loops executed.</div></blockquote>
</dd></dl>

</dd></dl>

<span class="target" id="module-segments.segments_IQ"></span><p>Class that can be used to construct IQ pulses for qubit control applications.</p>
<p>Possible pulses include:
* standard block pulse
* chirped pulse for adiabatic spin operation
* modulated pulsed.</p>
<p>As data format we will use a class to store
* type (std, chrip, mod)
* t0
* te
* freq1
* freq2 (opt)
* amp
* phase</p>
<dl class="class">
<dt id="segments.segments_IQ.segment_single_IQ">
<em class="property">class </em><code class="descclassname">segments.segments_IQ.</code><code class="descname">segment_single_IQ</code><span class="sig-paren">(</span><em>name</em>, <em>LO</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/segments_IQ.html#segment_single_IQ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.segments_IQ.segment_single_IQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard single segment for IQ purposes
todo –&gt; add global phase and time shift in the data class instead of this one (cleaner and more generic).</p>
<dl class="method">
<dt id="segments.segments_IQ.segment_single_IQ.get_IQ_data">
<code class="descname">get_IQ_data</code><span class="sig-paren">(</span><em>I_or_Q</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/segments/segments_IQ.html#segment_single_IQ.get_IQ_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#segments.segments_IQ.segment_single_IQ.get_IQ_data" title="Permalink to this definition">¶</a></dt>
<dd><p>get I and Q data from the main element.
Args:</p>
<blockquote>
<div>I_or_Q (str) : ‘I’/’Q’, denoting if you want the I or the Q channel</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>data (np.ndarray) : array with the objects inside</dd>
</dl>
</dd></dl>

</dd></dl>

<p># Initializing the library</p>
<p>The general object that will manage all the segments and the interection with the AWG is the pulse object. The pulse object is best created in the station.
<a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>python</p>
<blockquote>
<div>from pulse_lib.base_pulse import pulselib
p = pulselib()</div></blockquote>
<p><a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a></p>
<p>Let’s intitialize the AWG’s and make some channels in the pulse library
<a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a>python</p>
<blockquote>
<div><p># init AWG
awg1 = keysight_awg.SD_AWG(‘awg1’, chassis = 0, slot= 2, channels = 4, triggers= 8)
awg2 = keysight_awg.SD_AWG(‘awg2’, chassis = 0, slot= 3, channels = 4, triggers= 8)
awg3 = keysight_awg.SD_AWG(‘awg3’, chassis = 0, slot= 4, channels = 4, triggers= 8)
awg4 = keysight_awg.SD_AWG(‘awg4’, chassis = 0, slot= 5, channels = 4, triggers= 8)</p>
<p># add to pulse_lib
p.add_awgs(‘AWG1’,awg1)
p.add_awgs(‘AWG2’,awg2)
p.add_awgs(‘AWG3’,awg3)
p.add_awgs(‘AWG4’,awg4)</p>
<p># define channels
awg_channels_to_physical_locations = dict({‘B0’:(‘AWG1’, 1), ‘P1’:(‘AWG1’, 2),</p>
<blockquote>
<div>‘B1’:(‘AWG1’, 3), ‘P2’:(‘AWG1’, 4),
‘B2’:(‘AWG2’, 1), ‘P3’:(‘AWG2’, 2),
‘B3’:(‘AWG2’, 3), ‘P4’:(‘AWG2’, 4),
‘B4’:(‘AWG3’, 1), ‘P5’:(‘AWG3’, 2),
‘B5’:(‘AWG3’, 3), ‘G1’:(‘AWG3’, 4),
‘I_MW’:(‘AWG4’, 1), ‘Q_MW’:(‘AWG4’, 2),
‘M1’:(‘AWG4’, 3), ‘M2’:(‘AWG4’, 4)})</div></blockquote>
<p>p.define_channels(awg_channels_to_physical_locations)</p>
</div></blockquote>
<p><a href="#id13"><span class="problematic" id="id14">``</span></a>`
Now we have some channels, we can also specity delays (e.g. due to different lenght of coaxial cables, cables that pass through a mixer, …).
<a href="#id15"><span class="problematic" id="id16">``</span></a><a href="#id17"><span class="problematic" id="id18">`</span></a>python</p>
<blockquote>
<div># format : dict of channel name with delay in ns (can be posive/negative)
p.add_channel_delay({‘I_MW’:50, ‘Q_MW’:50, ‘M1’:20, ‘M2’:-25, })</div></blockquote>
<p><a href="#id19"><span class="problematic" id="id20">``</span></a><a href="#id21"><span class="problematic" id="id22">`</span></a></p>
<p>You might also want to define some virtual gates,
this can simply be done by defining:
<a href="#id23"><span class="problematic" id="id24">``</span></a><a href="#id25"><span class="problematic" id="id26">`</span></a>python</p>
<blockquote>
<div><dl class="docutils">
<dt>awg_virtual_gates = {‘virtual_gates_names_virt’ :</dt>
<dd><dl class="first last docutils">
<dt>[‘vP1’,’vP2’,’vP3’,’vP4’,’vP5’,’vB0’,’vB1’,’vB2’,’vB3’,’vB4’,’vB5’],</dt>
<dd>‘virtual_gates_names_real’ :</dd>
<dt>[‘P1’,’P2’,’P3’,’P4’,’P5’,’B0’,’B1’,’B2’,’B3’,’B4’,’B5’],</dt>
<dd>‘virtual_gate_matrix’ : np.eye(11)</dd>
</dl>
</dd>
</dl>
<p>}
p.add_virtual_gates(awg_virtual_gates)</p>
</div></blockquote>
<p><a href="#id27"><span class="problematic" id="id28">``</span></a>`
The matrix can be updated with (not yet implemented):
<a href="#id29"><span class="problematic" id="id30">``</span></a><a href="#id31"><span class="problematic" id="id32">`</span></a>python</p>
<blockquote>
<div>p.update_virtual_gate_matrix(my_matrix)</div></blockquote>
<p><a href="#id33"><span class="problematic" id="id34">``</span></a>`
To generate virtual channels for IQ signals, you can add the following code:
<a href="#id35"><span class="problematic" id="id36">``</span></a><a href="#id37"><span class="problematic" id="id38">`</span></a>python</p>
<blockquote>
<div><dl class="docutils">
<dt>awg_IQ_channels = {‘vIQ_channels’ <span class="classifier-delimiter">:</span> <span class="classifier">[‘qubit_1’,’qubit_2’],</span></dt>
<dd>‘rIQ_channels’ : [[‘I_MW’,’Q_MW’],[‘I_MW’,’Q_MW’]],
‘LO_freq’ :[MW_source.frequency, 1e9]
# do not put the brackets for the MW source
# e.g. MW_source.frequency
}</dd>
</dl>
<p>p.add_IQ_virt_channels(awg_IQ_channels)</p>
</div></blockquote>
<p><a href="#id39"><span class="problematic" id="id40">``</span></a>`
Where the virtual channels are the new names of the new channels created to do IQ channals. Each of these channels refer to a real channel (note that you can refer to the same real channel multiple times). It is recomendable to create one IQ virtual channel for each qubit.</p>
<p>Note to finize the initialisation of the pulse library, you should call:
<a href="#id41"><span class="problematic" id="id42">``</span></a><a href="#id43"><span class="problematic" id="id44">`</span></a>python</p>
<blockquote>
<div>p.finish_init()</div></blockquote>
<p><a href="#id45"><span class="problematic" id="id46">``</span></a>`
This will prepare all the segment/sequencing objects you might need later.</p>
<p>The code above can be placed in your station.</p>
<p># Generating segments</p>
<p>Segments come by default in containers (e.g. for all the channels (real/virtual) you defined).
Note that all segments in these containers are assumed to have the same length (so P1, P2, P3, …).</p>
<p>An example of defining some segments.
<a href="#id47"><span class="problematic" id="id48">``</span></a><a href="#id49"><span class="problematic" id="id50">`</span></a>python</p>
<blockquote>
<div>seg  = p.mk_segment(‘INIT’)
seg2 = p.mk_segment(‘Manip’)
seg3 = p.mk_segment(‘Readout’)</div></blockquote>
<p><a href="#id51"><span class="problematic" id="id52">``</span></a>`
Each segment has a unique name. This name we will use later for playback.</p>
<p>## Making your first pulse</p>
<p>To each segments you can add basic waveforms. Here you are free to add anything you want.
Some examples follow (times are by default in ns).
<a href="#id53"><span class="problematic" id="id54">``</span></a><a href="#id55"><span class="problematic" id="id56">`</span></a>python</p>
<blockquote>
<div># B0 is the barrier 0 channel
# adds a linear ramp from 10 to 20 ns with amplitude of 5 to 10.
seg.B0.add_pulse([[10.,0.],[10.,5.],[20.,10.],[20.,0.]])
# add a block pulse of 2V from 40 to 70 ns, to whaterver waveform is already there
seg.B0.add_block(40,70,2)
# just waits (e.g. you want to ake a segment 50 ns longer)
seg.B0.wait(50)
# resets time back to zero in segment. Al the commannds we run before will be put at a negative time.
seg.B0.reset_time()
# this pulse will be placed directly after the wait()
seg.B0.add_block(0,10,2)</div></blockquote>
<p><a href="#id57"><span class="problematic" id="id58">``</span></a>`
# Playback of pulses</p>
<p>Once pulses are added, you can define a sequence like:
<a href="#id59"><span class="problematic" id="id60">``</span></a><a href="#id61"><span class="problematic" id="id62">`</span></a>python</p>
<blockquote>
<div>SEQ = [[‘INIT’, 1, 0], [‘Manip’, 1, 0], [‘Readout’, 1, 0] ]</div></blockquote>
<p><a href="#id63"><span class="problematic" id="id64">``</span></a>`
Where (e.g.) init is played once (1) and has a prescalor of 0 (see Keysight manual)</p>
<p>This sequence can be added to the pulse object and next be uploaded.
<a href="#id65"><span class="problematic" id="id66">``</span></a><a href="#id67"><span class="problematic" id="id68">`</span></a>python</p>
<blockquote>
<div>p.add_sequence(‘mysequence’, SEQ)
p.start_sequence(‘mysequence’)</div></blockquote>
<p><a href="#id69"><span class="problematic" id="id70">``</span></a><a href="#id71"><span class="problematic" id="id72">`</span></a></p>
<p># Some examples of easy pulses:
(more advanced examples follow later)
* 1D scan
<a href="#id73"><span class="problematic" id="id74">``</span></a><a href="#id75"><span class="problematic" id="id76">`</span></a>python
seg  = p.mk_segment(‘1D_scan’)
#lets sweep the virtual plunger,
n_points = 100
swing = 1000 #mV
period = 1000 #ns</p>
<p>v_start =swing/2
step = swing/npoints</p>
<dl class="docutils">
<dt>for i in range(n_points):</dt>
<dd>seg.vP1.add_block(i*period, (i+1)period, v_start + i*step)</dd>
</dl>
<p>#done.
<a href="#id77"><span class="problematic" id="id78">``</span></a>`
* 2D scan
<a href="#id79"><span class="problematic" id="id80">``</span></a><a href="#id81"><span class="problematic" id="id82">`</span></a>python
seg  = p.mk_segment(‘2D_scan’)
#lets sweep the virtual plunger 1 versus virtual plunger 2,
n_points1 = 100
n_points2 = 100</p>
<p>swing1 = 1000 #mV
swing2 = 1000 #mV</p>
<p>period = 1000 #ns
period1 = period #ns
period2 = period*n_points1 #ns</p>
<p>v_start1 =swing1/2
step1 = swing1/npoints1
v_start1 =swing1/2
step1 = swing1/npoints1</p>
<dl class="docutils">
<dt>for i in range(n_points1):</dt>
<dd>seg.vP1.add_block(i*period1, (i+1)period1, v_start1 + i*step1)</dd>
</dl>
<p>seg.repeat(n_points2)
for i in range(n_points2):</p>
<blockquote>
<div>seg.vP1.add_block(i*period2, (i+1)period2, v_start2 + i*step2)</div></blockquote>
<p>#done.
<a href="#id83"><span class="problematic" id="id84">``</span></a>`
* 2D FM scan
<a href="#id85"><span class="problematic" id="id86">``</span></a><a href="#id87"><span class="problematic" id="id88">`</span></a>python
lets build on top of the perv sample. let att the modulation on the real plungers (1 and 2) and barrier (2).
seg.P1.add_sin(10e6, …)
…</p>
<p><a href="#id89"><span class="problematic" id="id90">``</span></a>`
* Ramsey experiment (using loops)
<a href="#id91"><span class="problematic" id="id92">``</span></a><a href="#id93"><span class="problematic" id="id94">`</span></a>python
seg  = p.mk_segment(‘Ramsey’)</p>
<p># do pi/2 pulse
seg.IQ.add_sin(0,100e-9,freq = 2e9, amp = 10, phase = 0)
# wait – use a loop object (has access to default numpy operators if it is numerical)
times = lp.linspace(5,20e3, 500, axis=0, name=”time”, unit=”ns”)
seg.IQ.wait(times)
# reset time
seg.IQ.reset_time()
# do pi/2 pulse
seg.IQ.add_sin(0,100e-9,freq = 2e9, amp = 10, phase = 0)
<a href="#id95"><span class="problematic" id="id96">``</span></a>`
One can see that here a call to a single loopobject it made. We will be sweeping from 50ns to 20us. This sweep axis is 0 (first axis). The default is always a new axis. You only need to explicitely specify it if you want to parameters to be coupled (e.g. swept on the same axis). The name is optional and can be used for plotting, same for the unit.</p>
<ul class="simple">
<li>Rabi experiment (power vs frequency of the pulse): Good example of a two dimensioal sweep</li>
</ul>
<p><a href="#id97"><span class="problematic" id="id98">``</span></a><a href="#id99"><span class="problematic" id="id100">`</span></a>python
seg  = p.mk_segment(‘RABI’)</p>
<p>t0 = 0
t1 = 50
freq = lp.linspace(1e9,1.1e9, 500, axis= 0, name=”frequency”, unit=”Hz”)
amp = lp.linspace(5,20e3, 500, axis= 1, name=”VoltageIQ”, unit=”a.u.”)
phase = 0
seg.IQ.add_sin(t0,t1,freq, amp, phase)
<a href="#id101"><span class="problematic" id="id102">``</span></a><a href="#id103"><span class="problematic" id="id104">`</span></a></p>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Stephan Philips

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>